package com.example;

import com.example.autogenerated.ObpfNativeInterface;
import com.example.autogenerated.ObpfTetromino;
import com.example.autogenerated.ObpfVec2;
import com.example.network.GameServerConnection;
import com.example.network.ServerMessage;
import com.example.ui.Mino;
import com.example.ui.Tetrion;
import javafx.application.Platform;

import java.io.DataInputStream;
import java.lang.foreign.Arena;
import java.lang.foreign.MemorySegment;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Stream;

public class Simulator {
    // is FPS capped to 60?
    private static final boolean FPS_CAPPED = !Boolean.parseBoolean(System.getProperty("javafx.animation.fullspeed", "false"));

    private final List<Tetrion> tetrions;

    // calculate when to simulate next frame
    private long lastSimulated = System.nanoTime();
    private long frame = 1;

    // Multiplayer Network
    private GameServerConnection conn;
    private List<int[]> keyStatesBuffer = new ArrayList<>(16);
    private final AtomicBoolean running = new AtomicBoolean(false);
    private final AtomicBoolean[] keysPressed = Stream.generate(AtomicBoolean::new).limit(7).toArray(AtomicBoolean[]::new);

    private int clientId;
    private long startFrame;

    private MemorySegment obpfTetrion;
    private MemorySegment obpfMatrix;

    private final CountDownLatch stop = new CountDownLatch(1);

    public Simulator(List<Tetrion> tetrions) {
        this.tetrions = tetrions;
    }

    public void gameHasStarted(int port) {
        conn = new GameServerConnection(port);
        Platform.runLater(() -> conn.start());

        var msg = conn.pollMessage();
        if (msg instanceof ServerMessage.GameStart gameStartMessage) {
            var seed = gameStartMessage.seed();
            clientId = gameStartMessage.clientId();
            startFrame = gameStartMessage.startFrame();

            obpfTetrion = ObpfNativeInterface.obpf_create_tetrion(seed.longValue());
            obpfMatrix = ObpfNativeInterface.obpf_tetrion_matrix(obpfTetrion);
            running.set(true);
        }
        try (var executor = Executors.newSingleThreadScheduledExecutor()) {
            executor.scheduleAtFixedRate(this::simulate, 0, 1, TimeUnit.MILLISECONDS);
            stop.await();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

    public void stopSimulating() {
        running.set(false);
        conn.stop();
    }

    public void setKeyState(int key, boolean isPressed) {
        if (!running.get()) return;
        keysPressed[key].set(isPressed);
    }

    private void simulate() {
        // if 16 ms elapsed, simulate next frame
        if (running.get()) {
            var now = System.nanoTime();
            if (FPS_CAPPED || (now - lastSimulated > 16_000_000)) {
                MemorySegment key_state = createKeyState();
                keyStatesBuffer.add(Stream.of(keysPressed).mapToInt(b -> b.get() ? 1 : 0).toArray());
                ObpfNativeInterface.obpf_tetrion_simulate_next_frame(obpfTetrion, key_state);
                lastSimulated = now;

                tetrions.getFirst().update(createGameBoard());

                if (frame % 15 == 0) {
                    conn.addHeartbeatMessage(new ServerMessage.HeartbeatMessage(frame, keyStatesBuffer));
                    keyStatesBuffer = new ArrayList<>(16);
                }
                frame++;
            }
        } else {
            stop.countDown();
        }
    }

    private List<Mino> createGameBoard() {
        List<Mino> gameBoard = new ArrayList<>(Tetrion.ROWS * Tetrion.COLS);
        // matrix
        try (var arena = Arena.ofConfined()) {
            var position = ObpfVec2.allocate(arena);
            for (byte y = 0; y < Tetrion.ROWS; y++) {
                for (byte x = 0; x < Tetrion.COLS; x++) {
                    ObpfVec2.x(position, x);
                    ObpfVec2.y(position, y);
                    var type = ObpfNativeInterface.obpf_matrix_get(obpfMatrix, position);
                    if (type != 0) {
                        gameBoard.add(new Mino(x, y, type, false));
                    }
                }
            }
        }
        // active piece
        try (var arena = Arena.ofConfined()) {
            var activeTetromino = ObpfTetromino.allocate(arena);
            ObpfNativeInterface.obpf_tetrion_try_get_active_tetromino(obpfTetrion, activeTetromino);
            var type = ObpfTetromino.type(activeTetromino);
            if (type != 0) {
                gameBoard.addAll(tetrominoToMino(activeTetromino, type, false));
            }
        }

        // ghost piece
        try (var arena = Arena.ofConfined()) {
            var ghostTetromino = ObpfTetromino.allocate(arena);
            ObpfNativeInterface.obpf_tetrion_try_get_ghost_tetromino(obpfTetrion, ghostTetromino);
            var type = ObpfTetromino.type(ghostTetromino);
            if (type != 0) {
                gameBoard.addAll(tetrominoToMino(ghostTetromino, type, true));
            }
        }
        return gameBoard;
    }

    private List<Mino> tetrominoToMino(MemorySegment tetromino, int type, boolean ghostPiece) {
        List<Mino> minos = new ArrayList<>();
        for (int i = 0; i < ObpfTetromino.mino_positions$dimensions()[0]; i++) {
            var vec2 = ObpfTetromino.mino_positions(tetromino, i);
            int x = ObpfVec2.x(vec2);
            int y = ObpfVec2.y(vec2);
            minos.add(new Mino(x, y, type, ghostPiece));
        }
        return minos;
    }

    private MemorySegment createKeyState() {
        return ObpfNativeInterface.obpf_key_state_create(Arena.ofAuto(),
                keysPressed[0].get(),
                keysPressed[1].get(),
                keysPressed[2].get(),
                keysPressed[3].get(),
                keysPressed[4].get(),
                keysPressed[5].get(),
                keysPressed[6].get());
    }

    public void tryConnect() {
        System.out.println("Connecting to Server...");
        try (var socket = new Socket("localhost", 8081)) {
            var in = new DataInputStream(socket.getInputStream());
            gameHasStarted(in.readInt());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
