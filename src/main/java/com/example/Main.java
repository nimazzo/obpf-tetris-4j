package com.example;

import com.example.autogenerated.ObpfNativeInterface;
import com.example.autogenerated.ObpfTetromino;
import com.example.autogenerated.ObpfVec2;

import java.lang.foreign.Arena;
import java.lang.foreign.MemorySegment;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.Arrays;
import java.util.Objects;
import java.util.Scanner;
import java.util.stream.IntStream;

public class Main {
    static final String DLL_PATH = System.getProperty("DLL_PATH");

    static {
        try {
            Objects.requireNonNull(DLL_PATH, "DLL_PATH must be set");
            Files.copy(Path.of(DLL_PATH), Path.of("./libs/obpf_d.dll"), StandardCopyOption.REPLACE_EXISTING);
        } catch (Exception e) {
            System.err.println("Failed to copy DLL: " + e.getMessage());
            System.exit(1);
        }
    }

    static long frame = 0;

    private static byte width;
    private static byte height;
    private static MemorySegment obpfTetrion;
    private static MemorySegment obpfMatrix;

    private static char[][] board;

    public static void main(String[] args) {

        width = ObpfNativeInterface.obpf_tetrion_width();
        height = ObpfNativeInterface.obpf_tetrion_height();

        board = new char[width][height];

        System.out.println("Tetrion width: " + width);
        System.out.println("Tetrion height: " + height);

        obpfTetrion = ObpfNativeInterface.obpf_create_tetrion(1234);
        obpfMatrix = ObpfNativeInterface.obpf_tetrion_matrix(obpfTetrion);

        simulate();

        ObpfNativeInterface.obpf_destroy_tetrion(obpfTetrion);
    }

    private static void drawGhostTetromino(MemorySegment outTetromino) {
        var type = ObpfTetromino.type(outTetromino);
        if (type == 0) {
            return;
        }
        System.out.println("Ghost piece: '" + tetrominoTypeToChar(type) + "'");
        for (int i = 0; i < ObpfTetromino.mino_positions$dimensions()[0]; i++) {
            var vec2 = ObpfTetromino.mino_positions(outTetromino, i);
            var x = ObpfVec2.x(vec2);
            var y = ObpfVec2.y(vec2);
            board[x][y] = 'G';
        }
    }

    private static void simulate() {
        var scanner = new Scanner(System.in);
        String lastInput = "";

        while (true) {
            // reset keys
            // left, right, down, drop, rotate_clockwise, rotate_counter_clockwise, hold
            final boolean[] keysPressed = new boolean[7];

            var input = scanner.nextLine();
            if (input.isBlank()) {
                input = lastInput;
            }
            lastInput = input;
            if (input.equalsIgnoreCase("exit")) {
                break;
            } else if (input.equalsIgnoreCase("L")) {
                keysPressed[0] = true;
            } else if (input.equalsIgnoreCase("R")) {
                keysPressed[1] = true;
            } else if (input.equalsIgnoreCase("D")) {
                keysPressed[2] = true;
            } else if (input.equalsIgnoreCase("SPACE")) {
                keysPressed[3] = true;
            } else if (input.equalsIgnoreCase("RC")) {
                keysPressed[4] = true;
            } else if (input.equalsIgnoreCase("RCC")) {
                keysPressed[5] = true;
            } else if (input.equalsIgnoreCase("H")) {
                keysPressed[6] = true;
            }

            // clear board
            Arrays.stream(board).forEach(row -> Arrays.fill(row, ' '));
            MemorySegment key_state = createKeyState(keysPressed);

            ObpfNativeInterface.obpf_tetrion_simulate_next_frame(obpfTetrion, key_state);
            frame++;
            if (IntStream.range(0, keysPressed.length).mapToObj(i -> keysPressed[i]).noneMatch(b -> b)) {
                System.out.println("Simulating extra 59 frames");
                frame += 59;
                for (int i = 0; i < 59; i++) {
                    ObpfNativeInterface.obpf_tetrion_simulate_next_frame(obpfTetrion, key_state);
                }
            }
            System.out.println("Frame: " + frame);
            try (var arena = Arena.ofConfined()) {
                var position = ObpfVec2.allocate(arena);
                for (var y = 0; y < height; y++) {
                    for (var x = 0; x < width; x++) {
                        ObpfVec2.x(position, (byte) x);
                        ObpfVec2.y(position, (byte) y);
                        var type = ObpfNativeInterface.obpf_matrix_get(obpfMatrix, position);
                        board[x][y] = tetrominoTypeToChar(type);
                    }
                }
            }

            drawGhostPiece();
            drawActivePiece();
            drawBoard();
        }
    }

    private static MemorySegment createKeyState(boolean[] keysPressed) {
        return ObpfNativeInterface.obpf_key_state_create(Arena.ofAuto(),
                keysPressed[0],
                keysPressed[1],
                keysPressed[2],
                keysPressed[3],
                keysPressed[4],
                keysPressed[5],
                keysPressed[6]);
    }

    private static void drawActivePiece() {
        try (var arena = Arena.ofConfined()) {
            var outTetromino = ObpfTetromino.allocate(arena);
            ObpfNativeInterface.obpf_tetrion_try_get_active_tetromino(obpfTetrion, outTetromino);
            drawTetromino(outTetromino);
        }
    }

    private static void drawTetromino(MemorySegment outTetromino) {
        var type = ObpfTetromino.type(outTetromino);
        if (type == 0) {
            return;
        }
        System.out.println("Active piece: '" + tetrominoTypeToChar(type) + "'");
        for (int i = 0; i < ObpfTetromino.mino_positions$dimensions()[0]; i++) {
            var vec2 = ObpfTetromino.mino_positions(outTetromino, i);
            var x = ObpfVec2.x(vec2);
            var y = ObpfVec2.y(vec2);
            board[x][y] = tetrominoTypeToChar(type);
        }
    }

    private static void drawBoard() {
        System.out.println("-".repeat(width * 2 + 2));
        for (var y = 0; y < height; y++) {
            System.out.print("|");
            for (var x = 0; x < width; x++) {
                System.out.print(board[x][y] + " ");
            }
            System.out.print("|");
            System.out.println();
        }
        System.out.println("-".repeat(width * 2 + 2));
    }

    private static char tetrominoTypeToChar(int type) {
        return switch (type) {
            case 0 -> ' ';
            case 1 -> 'I';
            case 2 -> 'J';
            case 3 -> 'L';
            case 4 -> 'O';
            case 5 -> 'S';
            case 6 -> 'T';
            case 7 -> 'Z';
            default -> throw new IllegalStateException("Unexpected value: " + type);
        };
    }

    private static void drawGhostPiece() {
        try (var arena = Arena.ofConfined()) {
            var outTetromino = ObpfTetromino.allocate(arena);
            ObpfNativeInterface.obpf_tetrion_try_get_ghost_tetromino(obpfTetrion, outTetromino);
            drawGhostTetromino(outTetromino);
        }
    }
}