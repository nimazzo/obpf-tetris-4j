package com.example;

import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.stream.Stream;

public class JextractRunner {
    static final String CPROJECT_PATH = System.getProperty("CPROJECT_PATH");

    static {
        // check if folder exists
        Objects.requireNonNull(CPROJECT_PATH, "CPROJECT_PATH must be set");

        if (!Path.of(CPROJECT_PATH).toFile().exists()) {
            System.err.println("C project path does not exist: " + CPROJECT_PATH);
            System.exit(1);
        }
    }

    private final List<String> includeDirs = new ArrayList<>();
    private String outputDir;
    private String targetPackage;
    private String libraryName;
    private String headerClassName;
    private String mainHeaderFile;

    public JextractRunner() {
    }

    public JextractRunner includeDir(String includeDir) {
        includeDirs.add(Path.of(CPROJECT_PATH).resolve(includeDir).normalize().toString());
        return this;
    }

    public JextractRunner outputDir(String outputDir) {
        this.outputDir = Path.of(outputDir).normalize().toString();
        return this;
    }

    public JextractRunner targetPackage(String targetPackage) {
        this.targetPackage = targetPackage;
        return this;
    }

    public JextractRunner libraryName(String libraryName) {
        this.libraryName = libraryName;
        return this;
    }

    public JextractRunner headerClassName(String headerClassName) {
        this.headerClassName = headerClassName;
        return this;
    }

    public JextractRunner mainHeaderFile(String mainHeaderFile) {
        this.mainHeaderFile = Path.of(CPROJECT_PATH).resolve(mainHeaderFile).normalize().toString();
        return this;
    }

    public int run() throws InterruptedException, IOException {
        if (includeDirs.isEmpty()) {
            throw new IllegalArgumentException("At least one include directory must be provided");
        }

        if (outputDir == null) {
            throw new IllegalArgumentException("Output directory must be provided");
        }

        if (targetPackage == null) {
            throw new IllegalArgumentException("Target package must be provided");
        }

        if (libraryName == null) {
            throw new IllegalArgumentException("Library name must be provided");
        }

        if (mainHeaderFile == null) {
            throw new IllegalArgumentException("Main header file must be provided");
        }

        var command = new ArrayList<String>();
        command.add("cmd");
        command.add("/c");
        command.add("jextract");
        command.addAll(includeDirs.stream().flatMap(includeDir -> Stream.of("--include-dir", includeDir)).toList());
        command.addAll(List.of("--output", outputDir));
        command.addAll(List.of("--target-package", targetPackage));
        command.addAll(List.of("--library", libraryName));

        if (headerClassName != null) {
            command.addAll(List.of("--header-class-name", headerClassName));
        }

        command.add(mainHeaderFile);

        System.out.println("Running: " + String.join(" ", command));

        var process = new ProcessBuilder()
                .command(command)
                .redirectOutput(ProcessBuilder.Redirect.INHERIT)
                .redirectError(ProcessBuilder.Redirect.INHERIT)
                .start();
        return process.waitFor();
    }

    public static void main(String[] args) throws IOException, InterruptedException {
        var code = new JextractRunner()
                .includeDir("src/obpf/include")
                .includeDir("src/common/include")
                .includeDir("cmake-build-debug/bin/obpf")
                .outputDir("./client/src/main/java")
                .targetPackage("com.example.autogenerated")
                .libraryName("obpf_d")
                .headerClassName("ObpfNativeInterface")
                .mainHeaderFile("src/obpf/include/obpf/main_header.h")
                .run();
        System.out.println("jextract exited with code: " + code);
    }
}
